As the back end is responsible for performing the image synthesis it contains the majority of the code that requires disscussion.
\input{./implementation/photon_map.tex}


\section{Raytracing (10 pages)}
\todo{Add the algorithm back in}
%\begin{algorithm}[H]
%\For{each pixel in output image}
%{
%	send pixel x, y to thread queue;
%}
%
%finish\_count := 0;
%
%\While{finish\_count != thread\_count}
%{
%	data := read from output queue
%
%	\If{data == pixel\_data}
%	{
%		send pixel data back to front end
%	}
%	\Else
%	{
%		finish\_count := finish\_count + 1;
%	}
%}
%
%\caption{Raytracing Algorithm}
%\end{algorithm}

\subsection{Algorithmic Overview}

\subsection{Threading Model (0.5 pages)}
As noted in the design section of this document raytracing related rendering methods are inherently easily parrelised as each
ray can be traced in its own thread, the method that the system uses to distribute the work that is needed to be done is
based on a producer consumer model whereby the work is fed into a queue of work items that can be read by any of the worker
threads, in order to perform this a queue implementation was needed, this can be found in the \texttt{queue.c} source file,
this queue is thread-safe and as such is suitable for this use case. When working with multiple threads it is important
to prevent as much global state as possible, within the system this is no different and as a rule global variables are not used
with the exception of the configuration structure, this is due to the fact that after the initial setup of the scene the data
during the start of the programs execution no data within the structure is permitted to be modified and as such can be read
safety from any thread. In order to inform each thread that all pixels have been processed a dummy input is sent to each of the
threads, on reading this input the thread will return.

\missingfigure{Threading Model}

The choice of mulitthreading library that I have used is pthreads. Posix threads are a definition
of a threading model that allows C programs to be run on muliple threads, pthreads are defined for unix like systems so
linux and mac os are supported so partially fulfills requirement \todo{add requerement refs}: as windows does not have native
support for pthreads, there is however an implementation that uses native Windows threads to present the types and functions defined
by pthreads. As I am using C11 it could be possible to use the threading functionallity that is defined in the standard,
unfortunatally the support for this feature is largly unsupported (as of \today).

\subsection{Pixel Sampling}
As the raytracer is performing distribution raytracing each thread will perform multiple raytracing operations for each pixel
that it processes each sample per pixel is offset inside the pixel to perform antialiasing, this reduces the sharp edges that
can be seen in images. In order to improve the appearence of the image we also perform jittering on the samples this reduces
certain artifacts such as banding. \todo{Make sure the banding comment is correct and if so find a reference for it}

\missingfigure{anti-aliasing}

\subsection{Intersection Storage}
When raytracing the scene the intersection point of the ray needs to be calculated and stored, this will include data that
is specific to an objects intersection, for example an intersection with a triangle mesh will need to record the trangle
that was intersected and as a result will need to record the barycentric coordinate at the point of intersection.

\subsection{Object System}
In order to meet requirement \todo(find requirement to ref) the system needs to be able support arbitrary objects descriptions
that can be traced in the scene, this is implementatied as a structure that contains function pointers that perform functions
that must be supported by all raytracable objects and the data related to the individual object.

\begin{description}
\item[normal] returns the normal at a point of intersection.
\item[bounds] return the bounds for the object.
\item[texture] return the texture coordinates at a point of intersection
\item[intersection] returns if a ray intersects a given object.
\end{description}

By encapsulating the data and the functions performed by the object it is possible to create algorithms on objects in the
abstract such that the details of the object can be ignored, for instance calculating a reflected ray at a point if intersection
is a function of only the surface normal at that point, wheither it is a triangle mesh or sphere the same ray will be calculated.

\subsubsection{Texture Mapping}
Performing texture mapping requires the ability to query the texture coordinates at a point of intersection, for mesh objects this
will interpolate the barycentric coordinates for the triangle of intersection, spheres use a spherical mapping that uses the
spherical coordinates to generate u,v values.

\subsubsection{Mesh}
The mesh type is defnined as a list of vertices and triangles constisting of indices into the list of vertices.

\subsubsection{Sphere}
The sphere type is simply defined as a origin point and radius.

\subsubsection{Participating Media}
The participating media type is created by applying a participating media materail property to an object, this allows
for arbitrary geometry to be used as a participating media.

\subsection{K-D Tree Construction}
In order to satisy requirement TODO:Add the requirement bruteforce methods for raytracing are not acceptable, in order to reduce
to number of intersection tests that are performed I have decided to use the kdtree for the accelleration structure. The
construction of the kdtree is performed during the initialiseation of the triangle meshes as it is a static data structure, due
to it being a static data structure their is an advantage to performing more extensive computation in the construction in
order to create a higher quality of kdtree. TODO:Add sah and analysis.

\subsection{Intersection Tests (0.5 pages)}
Intersection tests are another vital part of any raytracer. a number of intersection tests are needed, I will not include
an extensive treatment of the intersection tests mearly a listing of the most notable used.

\begin{description}
\item[Triangle] Moller-Trumbore intersection test \cite{MolTru97}
\item[AABB]
\item[kD-tree] As described in TODO:
\end{description}

\subsection{volume intersection}
Unlike intersection with all other object types the intersection with a participating media is non deterministic, this is
due to the fact that the intersection of the ray is determined by the extinction coefficient which gives a probablilty
of interaction, the depth of the interaction is calculated with equation \todo{add equation}, performing this non-deterministic
intersection test allows for objects within the medium to be interacted with when performing ray-marching.

\missingfigure{Non-deterministic intersection test}
\subsection{Photon Mapping}
For each of the intersection points that are found as a result of the raytracing algorithm we must calculate the global
illumination at the point, this is performed with the photon maps that are associated with the scene.

\subsection{Nearest Neighbour search}
\todo{Find the correct location for this}
By far the most expensive operation in the photon mapping algorithm is the nearest neghbour search as we perform
many more of these operations per pixel, for radiance estimates that contain tens, hundreeds or thousands of photons
efficiently finding the $n$ closest photons is important.

\missingfigure{Nearest neighbour search}

\subsection{Sampling Strategy}
Many times within the code there is a need to sample from different distributions such as sampling from a hemisphere
of directions around a normal, the need for this can be seen from the definition of the radiance estimate given in
the desctription of the photon mapping algorithm as we will be evaluating the integral with monte carlo methods.

\subsection{Shading}
The intersection point of the primary ray is used as the point where we will evaluate the radiance for that will determin
the colour of the pixel, this is done by combining the result of direct lighting, indirect lighting, castics and if present
scattering and attenuation due to participating media, this is commonly expressed as a sum of integrals that sum to a solution
to the rendering equation, equation \todo{Add the equation} shows this.

\subsubsection{Direct Illumination}
Direct illumination can be calculated direclty by calculating the radiance incident to the intersection point for each of the
lights in the scene.

\missingfigure{Direct Illumination}

\subsubsection{Caustic Contribution}
Caustic illumintation indirect illumitionan from photons that take purly specular paths prior to being stored at a non-specular
surface.

\subsubsection{Multiple diffuse bounves and final gathering}

While it is possible to estimate the contribition to the radiance at an intersection point directly from the photon map this
approach can cause visual artifacts due to variance in the estimate in order to reduce these artifacts we perfom a final gather
stage at the point of intersect that produces a diffuse ray that is traced into the scene until a non-specular object is intesected,
we then perform the radiance at this point and use this information to estimate the radiance incident at the original point of intersection.
In order for the final gather to produce a correct estimate of the radiance we need to perform this stage multiple times per pixel, as we
are performing distributed raytracing this is a trivial addition. When calcualting the radiance for the final gather it has been shown \todo{cite}
that if the distance of the final gather point is lower than some threshold perfoming an additional diffuse bounce reduces errors at geometry
such as sharp corners where the radiance estimate can be inaccurate due to accounting for photons not truly at the surface.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{./images/final_gather.png}
\label{fig:final_gather}
\caption{Final Gather}
\end{figure}

\subsection{Volume Contribution}
In the case of a ray that intersects a participating media before intersecting a surface we need to calculate three components to
the radiance along the path of the ray in the medium, these are single scattering direct illumination, multiple scattering (in-scattering)
and attenuation (out-scattering)

\subsubsection{Attenuation}
As a ray travels through a medium the radiance can be reduced due to out-scattering and absortion, this can be calculated by evaluating
the integral given in equation \todo{Add the equation}, as we are only considering homogeneous participating media this can be
simplified as the properties being integrated are constant and a closed form solution is possible.

\missingfigure{Attenuation Equation}

\subsubsection{Direct Illumination}
\subsubsection{Muliple Scattering}

