\section{Photon Map Generation}
As thousands of photons can potentially be created it makes sense to utilise the hardware that the system is running on, this
includes multiple cores, the photon emiition is as a result designed to run on multiple threads.

Each thread is responsible for producing a certain proportion of the photons in the scene, once a thread has processed all
of these photons it will signal to the main thread that it has finished by sending a flag to the output queue the thread also
updates a global light emission count include the photons that the thread emitted for each of the lights, a seperate count for
each of the counts is kept as the processing of the threads may not happen at the same time.

\subsection{Photon Emission}
In order to trace photons into the scene we first need a method of creating photons, this is implemented in the light 
defintion, each light object has a associated function that will produce a random photon from the light that is consitent with 
the type of light, for instance a point light will generate a photon with origin exactlu at the origin of the light source and
in a random direction, an area light produces a photon with origin on the area of the light with direction taken from a
cosine weighted hemisphere distribution in the direction of the normal of the light. Each photon that is emitted from the
light sources begin with the full power of the light source, this will be scaled by the number of emitted photons after
all photons have been gathered.

\subsection{Photon Tracing}
Once we have created a photon from a light source we now need to trace the photon through the scene and record the interactions
of the photon until it is absorbed or leaves the scene, the function that performes this function is \texttt{trace\_photon} the
declaration of this function is given below.

\texttt{int trace\_photon(scene\_t *scene, ray\_t *ray, int light, double power[3], bool specular, bool diffuse, bool specular\_only};

The parameters ray, light and power defines the photon properties, ray defines the origin and direction of the photon, light is an index
to the light from which this light was emited and the power contains the flux of the photon. specular and diffuse
define describe the path that the photons have taken prior to the call to \texttt{trace\_photon}

Photons are traced much like a ray in traditional raytracing, first we calculate the closest intersection point of the photon
once found the photon interacts with the surface of the object at the point of intersection this interaction can be specular 
reflection , transmission, diffuse reflection or absorbtion. Now that we have a point of intersection we must decide what
to do with the photon, this is determined by the reflectance of the object at the point of intersection, if for instance the
object reflectes fifty percent of light in the specular direction and the other fifty percent diffusely we could create two
photons, one that is traced in the specular direction and another in a random direction sampled around the hemisphere in the
direction of the surface normal, each with half of the power of the incoming photon.

As noted by Jensen, this approach would work but can lead to photons with very low power, more of a concern is that this approach leads to an exponential number of
photon interactions, as a result we use the monte-carlo method described by Jensen \cite{JensenBook} that reflectes at most one photon
per surface interaction with full power, to make this technique give the same answer as the previous method we make the
decition based on the reflectivity of the surface by forming a cumulative distribution function.  
Given the specular reflecive, transmissive and diffuse reflectance coefficents $\rho_{s}, \rho_{t}, \rho_{d}$
of the object we can create a cumulative distribution of photon emittion paths (Figure~\ref{fig:rr_dist}) 
we then take a uniform variable $\xi$ in the range from 0 to 1. As we are using rgb values to store reflectance properties the
coeffients used to perform the sampling are the average of the three componenets, so as the distribution of the three
colour bands is correct we must also perform scaling of the power parameter that we use in the next \texttt{trace\_photon}
call, note that the scaling preserves the power of the photon it mearly redistributes it.

\begin{figure}[h]
\includegraphics{./images/russian_roulette_distribution.png}
\label{fig:rr_dist}
\caption{Russian roulette distribution}
\end{figure}

If the photon intersects a surface with non-specular components the photon is written to the output queue, 
the tracing thread will write the photon data that is to be stored in
the photon map along with infomation that describes the path that the photon has taken, the power of the photon and the
incident angle of the photon with the surface to a queue that will be read by the main thread.
The desctiption of the path that the photon is described by flags passed to the photon tracing function,
two flags are used to describe the path, a diffuse flag and a specular flag both are initially set to false if a diffuse
surface is intersected the diffuse flag is set to true the same being true for specular intersections and the specular flag.

For specular reflection and transmission a photon is created at the point of intersection that has normal in the reflected
or transmitted direction, as noted by Jensen \cite{JensenBook} storing photons at specular surfaces does not add any useful
information for rendering as the probability of the photon being used in the radiance estimate is zero due to the
delta function in specular BRDF's

When creating the caustic photon map we are only concerned with those interactions with diffuse surfaces that have
taken a path that contains at least one specular bounce and no diffuse bounces (\textbf{LS$^+$DE}), as a result \texttt{trace\_photon}
has as input a flag that will indicate that any path that does not match this description should be discarded.

\subsubsection{Participating Media}
If the photon interacts with a participating medium the photon will begin a random walk inside the medium, this walk
is determined by the properties of the medium, these being the scattering and absorbtion coefficient, the sum of which
is called the extinction coefficient, at each point in the random walk the photon is stored and then can either be
scattered or absorbed, the probability of being scattered is determined by the Albedo $\Lambda$

\missingfigure{random walk}

\begin{equation}
\Lambda = \frac{\sigma_s}{\sigma_e}
%\caption{Participating Media Albedo}
\end{equation}

As discussed by Jensen \todo{cite} the marching can be performed with a set distance and scaling of the photons at each
step, a more efficient method is to importance sample the distance $\Delta x$ of the next interaction with 
Equation~\ref{eq:volume_dist_importance}, the scattering of the photon continues until the photon is absorbed, intersects
with an object in the medium or exits the medium.

\begin{equation}
\Delta x = \frac{-log(\xi)}{\sigma_t(x)}
%\caption{Photon marching importance function}
\label{eq:volum_dist_importance}
\end{equation}

\subsection{Photon Processing}
As each thread produces photons they write the photons to a queue, this queue is subsequently read by the main thread where
the photons will be places into a list bases upon the path that the photon took, for purly specular paths the photons
will be added to the caustinc photon map, for paths that end with an interaction with a participating media they will be
added to the volume photon map, all other paths are added to the global photon map. Once all photons have been collected
into the lists the main thread iterates over the photons and adjusts the photon power by the number of photons emitted by
the light that emitted the photon. \todo{clean up}

\subsection{K-D Tree Balancing (1 page)}
When performing radiance estimations with the photon map we will be performing nearest neighbour searches on points within
the map, this requires the photon map to be arrainged in a manner such that this search can be performed efficiently.
In order to do this we store the photon map in a left-balanced k-d tree. A left balanced tree is a tree structure where
at each level of the tree the depth of the children differs by at most one, \todo{finish the explination of the LEFT balanced tree}
this allows us to store the photon map in an array with the location of the children in the photon map known implicitly,
for a photon in position $i$ the children of the photon can be found at the $(2i + 1)^{th}$ and $(2i + 2)^{th}$
location for the left and right tree respectivly.

\begin{algorithm}
\begin{algorithmic}
\caption{Balanced K-D tree construction}
\Function{balance}{photons, index, max\_index}
\If
{
photons.size \textgreater 1
}
{

	axis $\gets$ \Call{select\_axis}{photons}

	left, median, right $\gets$ \Call{partition\_around\_median}{photons, axis}

	left\_index  $\gets$ 2 * index + 1

	right\_index $\gets$ 2 * index + 2

	\If{left\_index \textless max\_index}
	{

		left $\gets$ \Call{balance}{left, left\_index,max\_index}
	}
	\EndIf

	\If{right\_index \textless max\_index}
	{

		right $\gets$ \Call{balance}{right, right\_index, max\_index}
	}
	\EndIf

	\Return{left + median + right}
}
\Else
{

	\Return{photons}
}
\EndIf
\EndFunction
%\State colour $\gets$ scene.sky\_colour
%\For{object $\in$ scene}
%
%	new\_record $\gets$ intersects(ray, object)
%
%	\If{new\_record.hit \textbf{and} new\_record.t $\textless$ record.t}
%
%	record $\gets$ new\_record
%
%	\EndIf
%
%\EndFor
%
%\If{record.hit}
%
%	colour $\gets$ shade(scene, record)
%\EndIf
%
%\Return colour

\end{algorithmic}
\end{algorithm}

\begin{figure}
\centering
\includegraphics[scale=0.75]{./images/left-balanced-tree.png}
\caption{Left balanced tree and its memory layout}
\end{figure}

\subsubsection{Selection Statistic}
During the balancing procedure we need to partition the tree such that half the elements are less than the median
this can be seen as finding the $i/2^{th}$ largest element in the list, this can be performed in linear time by using
the median of medians algorithm . Below is a comparison for the runnning time of the balancing procedure for
the nieve selection algorithm and the median of medians algorithm. As we are left-balancing the tree we also cannot
just take the median of the data, we must adjust the median such that the left half of the tree will fill before the right.
\todo{expand and add psuedocode}
